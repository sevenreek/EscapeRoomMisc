/**
 * This version is created with the Arduino Pro Mini 3.3V in mind.
 * With minor conversions also worked on the Arduino Mega 2560
 */
 /* INCLUDES */
#include "Potentiometer.h"
#include "SoundPlayer.h"
#include "DS2401.h"
#include <Adafruit_GFX.h>
#include "Adafruit_LEDBackpack.h"
#include <math.h>
#include <string.h>
/* BASIC CONFIGURATION */
#define KNOB_COUNT (4)
#define CORRECT_FREQUENCY_COUNT (3)
/* MP3 FILES DEFINITIONS */
#define RADIO_NOISE (4) 
#define RADIO_MORSE (3)
#define RADIO_CHATTER0 (2)
#define RADIO_CHATTER1 (1)
/* PIN DEFINITIONS */
#define ARDUINO_TX_PIN (11) // Arduino pin used as the software transimtter. Connect to the mp3 module RX pin.
#define ARDUINO_RX_PIN (10) // Arduino pin used as the software reciever. Connect to the mp3 module TX pin. Not actually necessary, as no data is read from the mp3 module atm.
#define ARDUINO_VOLUME_PIN (A6) // used for volume control
#define ARDUINO_SDA_PIN (0x70) // A4 - SDA; A5 - SCL
#define ARDUINO_DS2401_PIN (7)
/* SOFTWARE SERIAL DEFINITIONS */
#define SSERIAL_BAUDRATE 9600
/* CONSTANTS */
const uint16_t knobPins[KNOB_COUNT] = {A0,A1,A2,A3}; // analog pins on the arduino that are connected to the middle terminal of the potentiometers. Connect the other two ends to VCC and GND
const uint16_t knobMaxes[KNOB_COUNT] = {1023,1023,1023,1023}; // Maximum value read by the analog pin from the extreme setting of a potentiometer
const uint16_t knobMins[KNOB_COUNT] = {0,0,0,0}; // Minimum value read by the analog pin from the other extreme setting of a potentiometer
const uint16_t MAX_FREQUENCY = 9; // Maximum frequency generated by a single knob. Changing this to a value greater than 9 will likely require changes in the comparison condtions and display
const uint16_t MIN_FREQUENCY = 0; // minimum frequency -||-
const byte CORRECT_DS2401[8] = {0x01,0x0B,0xB7,0xFE,0x1A,0x00,0x00,0x9F}; 
uint16_t correctFrequencies[CORRECT_FREQUENCY_COUNT] = {7982,3456,1024}; // Frequency index (first element's index is 0) has to correspond to the MP3 file definition of index+1(second frequency will play the sound defined as (2))
/* GLOBALS */
uint8_t currentPlayedSound = RADIO_NOISE;
uint16_t currentFrequency;
int lastReadVolume;
KnobController * knobReaders[KNOB_COUNT];
KnobController * volumeReader = NULL;
Adafruit_7segment matrix = Adafruit_7segment();
SoundController * soundPlayer = NULL;
DS2401 * ds2401 = NULL;
/* FUNCTION PROTOTYPES */
uint16_t convertPercentToFrequency(float percentage, uint16_t minF, uint16_t maxF);
bool isCorrectDS2401Connected(const byte* correctSignature);
/* FUNCTION setup()
 * In the setup the class wrappers are initialized. The display is configured not to display anything, so
 * as to seem off. The sound player is set to play the radio noise and immediately paused.
 */
 int freeRam();
int freeRam () {
  extern int __heap_start, *__brkval; 
  int v; 
  return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval); 
}
void setup() {
  Serial.begin(115200);
  Serial.println("Rebooting...");
  delay(100);
  soundPlayer = new SoundController(ARDUINO_RX_PIN, ARDUINO_TX_PIN, SSERIAL_BAUDRATE);
  ds2401 = new DS2401(ARDUINO_DS2401_PIN);
  int i;
  for(i=0;i<KNOB_COUNT;i++)
  {
    knobReaders[i] = new KnobController(knobPins[i],knobMins[i],knobMaxes[i]);
  }
  volumeReader = new KnobController(ARDUINO_VOLUME_PIN,0,1024);
  matrix.begin(ARDUINO_SDA_PIN);
  matrix.clear();
  matrix.writeDisplay(); 
  soundPlayer->playLoop(RADIO_NOISE);
  soundPlayer->pause();
  Serial.println(freeRam());
  delay(2000);
}
/* FUNCTION loop()
 * Every update the board checks if the correct DS2401 element is still connected. If it is it allows the
 * loop to move forward, turns on the display and reads the frequency. Otherwise it returns from the loop
 * early waiting for the element to be connected. Once the correct frequency is set the appropriate sound is
 * played.
 */
void loop() {
   // untill the "battery" in the form of the DS2401 chip is not connected do not play any sounds.
  if( isCorrectDS2401Connected(CORRECT_DS2401) )
  {
    Serial.println(F("Correct connection"));
    soundPlayer->resume();
  }
  else
  {
    Serial.println(F("Incorrect connection"));
    soundPlayer->pause();
    matrix.clear();
    matrix.writeDisplay(); // the display starts "off", not showing anything
    return;
  }
 
  int readVolume = volumeReader->getCurrentPosition()*30; 
  //Serial.println(readVolume);
  if(readVolume!=lastReadVolume)
  {
    soundPlayer->volume( readVolume);
    lastReadVolume = readVolume;
  }
  int i;
  currentFrequency = 0;
  for(i=0;i<KNOB_COUNT;i++)
  {
    uint8_t readDigit = convertPercentToFrequency( knobReaders[i]->getCurrentPosition(), MIN_FREQUENCY, MAX_FREQUENCY  );
    uint16_t valToAdd = readDigit;
    int j;
    for(j=KNOB_COUNT-i-1;j>0;j--)
      valToAdd*=10;
    matrix.writeDigitNum( i>1 ? i+1:i, readDigit); // position 2 in writeDigitNum is not the next digit but controls the dots
    currentFrequency += valToAdd;
    //Serial.print("RD: "); Serial.print(readDigit);  Serial.print(" FRQ: "); Serial.println(currentFrequency);
  }
  matrix.writeDisplay();
  bool isCorrectFrequency = false;
  for(i=0;i<CORRECT_FREQUENCY_COUNT;i++)
  {
    if(correctFrequencies[i]==currentFrequency)
    {
      Serial.print(F("Matching "));Serial.println(i);
      isCorrectFrequency = true;
      if((i+1)!=currentPlayedSound)
      {
        soundPlayer->playLoop(i+1);
        currentPlayedSound = i+1;
      }   
    }
  }
  if(!isCorrectFrequency && currentPlayedSound!=RADIO_NOISE)
  {
    soundPlayer->playLoop(RADIO_NOISE);
    currentPlayedSound = RADIO_NOISE;
  }

}
uint16_t convertPercentToFrequency(float percentage, uint16_t minF, uint16_t maxF)
{
  return roundf(percentage*(maxF-minF)+minF);
}
bool isCorrectDS2401Connected(const byte* correctSignature)
{
  byte data[8];
  uint8_t result = ds2401->readData(data);
  uint8_t comparisonResult = 1;
  if(result == RESULT_SUCCESS)
  {
    comparisonResult = memcmp(data,correctSignature,8);
    if(comparisonResult == 0)
      return true;
    else
      return false; 
  }
  else
    return false; // if DS2401 is not found return false.
  
}
