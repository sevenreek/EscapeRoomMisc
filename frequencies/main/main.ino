/**
 * This version is created with connections on the Arduino Pro Mini 3.3V 
 * 
 */
#include "DFRobotDFPlayerMini.h"
#include "Potentiometer.h"
#include "DS2401.h"
//#include <Wire.h> // Enable this line if using Arduino Uno, Mega, etc.
#include <Adafruit_GFX.h>
#include "Adafruit_LEDBackpack.h"
#include <string.h>
#include <NeoSWSerial.h>
/* BASIC CONFIGURATION */
#define KNOB_COUNT (4)
#define CORRECT_FREQUENCY_COUNT (3)
/* MP3 FILES DEFINITIONS */
#define RADIO_NOISE (4) 
#define RADIO_MORSE (3)
#define RADIO_CHATTER0 (2)
#define RADIO_CHATTER1 (1)
/* PIN DEFINITIONS */
#define ARDUINO_TX_PIN (11) // Arduino pin used as the software transimtter. Connect to the mp3 module RX pin.
#define ARDUINO_RX_PIN (10) // Arduino pin used as the software reciever. Connect to the mp3 module TX pin. Not actually necessary, as no data is read from the mp3 module atm.
#define ARDUINO_VOLUME_PIN (A6) // used for volume control
#define ARDUINO_SDA_PIN (0x70) // A4 - SDA; A5 - SCL
#define ARDUINO_DS2401_PIN (7)
/* SOFTWARE SERIAL DEFINITIONS */
#define SSERIAL_BAUDRATE 9600
/* CONSTANTS */
const uint16_t knobPins[KNOB_COUNT] = {A0,A1,A2,A3}; // analog pins on the arduino that are connected to the middle terminal of the potentiometers. Connect the other two ends to VCC and GND
const uint16_t MAX_FREQUENCY = 9; // Maximum frequency generated by a single knob. Changing this to a value greater than 9 will likely require changes in the comparison condtions and display
const uint16_t MIN_FREQUENCY = 0; // minimum frequency -||-
const  byte CORRECT_DS2401[8] = {0x01,0x0B,0xB7,0xFE,0x1A,0x00,0x00,0x9F}; 
/* GLOBALS */
volatile uint16_t correctFrequencies[CORRECT_FREQUENCY_COUNT] = {7982,3456,1024}; // Frequency index (first element's index is 0) has to correspond to the MP3 file definition of index+1(second frequency will play the sound defined as (2))
uint8_t currentPlayedSound = RADIO_NOISE;
uint16_t currentFrequency;
int lastReadVolume;

KnobController * knobReaders[KNOB_COUNT];
KnobController * volumeReader = NULL;
Adafruit_7segment matrix = Adafruit_7segment();
DS2401 * ds2401 = NULL;
DFRobotDFPlayerMini soundPlayer;
NeoSWSerial softSerial(ARDUINO_RX_PIN,ARDUINO_TX_PIN);
/* FUNCTION PROTOTYPES */
uint16_t convertPercentToFrequency(float percentage, uint16_t minF, uint16_t maxF);
void onDS2401Removed();
void setup() {
  Serial.begin(115200);
  Serial.println("Rebooting...");
  softSerial.begin(SSERIAL_BAUDRATE);
  soundPlayer.begin(softSerial);
  //soundPlayer = new SoundController(ARDUINO_RX_PIN, ARDUINO_TX_PIN, SSERIAL_BAUDRATE);
  ds2401 = new DS2401(ARDUINO_DS2401_PIN);
  int i;
  for(i=0;i<KNOB_COUNT;i++)
  {
    knobReaders[i] = new KnobController(knobPins[i],0,1023);
  }
  volumeReader = new KnobController(ARDUINO_VOLUME_PIN,0,1023);
  matrix.begin(ARDUINO_SDA_PIN);
  matrix.clear();
  matrix.writeDisplay();
  soundPlayer.loop(RADIO_NOISE);
  soundPlayer.pause();
}

void loop() {
  //if(soundPlayer.readCurrentFileNumber() != currentPlayedSound) // Checks if some disturbance on Tx line did not cause the
  //  soundPlayer.loop(currentPlayedSound);                       // sound player to not get the loop message. It happened
  if(ds2401->isCorrectDS2401Connected(CORRECT_DS2401))          // on the breadboard occasionally.
  {
    soundPlayer.start(); 
    int readVolume = volumeReader->getCurrentPosition()*30; 
    if(readVolume!=lastReadVolume)
    {
      soundPlayer.volume( readVolume);
      lastReadVolume = readVolume;
    }
    int i;
    currentFrequency = 0;
    for(i=0;i<KNOB_COUNT;i++)
    {
      uint8_t readDigit = convertPercentToFrequency( knobReaders[i]->getCurrentPosition(), MIN_FREQUENCY, MAX_FREQUENCY  );
      uint16_t valToAdd = readDigit;
      int j;
      for(j=KNOB_COUNT-i-1;j>0;j--)
        valToAdd*=10;
      matrix.writeDigitNum( i>1 ? i+1:i, readDigit); // position 2 in writeDigitNum is not the next digit but controls the dots hence the ternary expression
      currentFrequency += valToAdd;
      
    }
    matrix.writeDisplay();
    bool isCorrectFrequency = false;
    for(i=0;i<CORRECT_FREQUENCY_COUNT;i++)
    {
      if(correctFrequencies[i]==currentFrequency)
      {
        isCorrectFrequency = true;
        if((i+1)!=currentPlayedSound)
        {
          soundPlayer.loop(i+1);
          currentPlayedSound = i+1;
        }
        break;
      }
    }
    if(!isCorrectFrequency && currentPlayedSound != RADIO_NOISE) // If the frequencies do not match radio noise is played unless it is already being played
    {
      soundPlayer.loop(RADIO_NOISE);
      currentPlayedSound = RADIO_NOISE;
    }
  }
  else
  {
    onDS2401Removed();
  }
}
void onDS2401Removed()
{
  soundPlayer.pause();   // Stop sound effects
  matrix.clear();        // Clear the 7seg screen buffer
  matrix.writeDisplay(); // Push empty buffer to the display
}
uint16_t convertPercentToFrequency(float percentage, uint16_t minF, uint16_t maxF)
{
  uint16_t result = (uint16_t)(percentage*(maxF+1-minF)+minF);
  return result>maxF?maxF:result;
}
